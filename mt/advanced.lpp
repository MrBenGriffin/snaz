%{
/* C++ string header, for string ops below */
#include <string>
#include <iostream>
#include <sstream>
#include <support/Message.h>

/* Implementation of yyFlexScanner */ 
#include "parser.tab.hpp"

#include "mt/Scanner.h"
namespace mt {
	class Advanced : public Scanner, public aFlexLexer {
	public:
		Advanced(Support::Messages& m,std::istream *in) : Scanner(m),aFlexLexer(in) {}
		virtual ~Advanced() = default;
		using aFlexLexer::yylex;
		virtual int yylex(mt::Parser::semantic_type *const,mt::Parser::location_type*);
		virtual void LexerError(const char* msg) {
			std::string err(msg);
			errs << Support::Message(Support::fatal,err);
    }
	private:
		mt::Parser::semantic_type *yylval = nullptr;
	};
}

#undef  YY_DECL
#define YY_DECL int mt::Advanced::yylex( mt::Parser::semantic_type * const lval, mt::Parser::location_type *loc )

/* typedef to make the returns for the tokens shorter */
using token = mt::Parser::token;

/* define yyterminate as this instead of NULL */
#define yyterminate() return( token::END )

/* update location on matching */
#define YY_USER_ACTION loc->step(); loc->columns(yyleng);
//offset+=yyleng;

%}

%option debug
%option yyclass="mt::Advanced"
%option prefix="a"
%option noyywrap noinput nounput nodefault
%option noyymore
%option never-interactive
%option c++
%option stack
%option warn
%x macro fatmac parm brace bracket literal injection

  /** ,\t\n()⌽⍟⎡⎤⎣⎦❪❫ **/
DELIMITER	,
BRACKET_IN	\(
BRACKET_OUT	\)
FAT_ONE_IN	❪
FAT_ONE_OUT	❫
LITERAL_IN	⎣
BRACE_IN	⎡
BRACE_OUT	⎤
INJECT_SIGN	⍟
I_OFFSET	(^*)
I_NUMBER	([0-9]+)
I_ITS		[ijkn]
I_STACK		p(s|[0-9]+)?
I_ITER		([ijkn]([.+-][0-9]+)?)
I_MORE		([0-9]+("+"?))
MACRO_SIGN	⌽
MACRO_NAME	[a-zA-Z_0-9]+
WHITESPACE	[\t\x0d\x0a]+

	/** ⎦: \xe2 \x8e \xa6 **/
LITERAL_OUT			⎦
NOT_LITERAL_OUT		(([^\xe2])|(\xe2[^\x8e][^\0])|(\xe2\x8e[^\xa6]))

NOT_SPECIAL_1C		([^\t\x0d\x0a,\(\)\xe2])
NOT_SPECIAL_3C		(\xe2(([^\x8c\x8d\x8e\x9d][^\0])|(\x8c[^\xbd])|(\x8d[^\x9f])|(\x8e[^\xa1\xa3\xa4])|(\x9d[^\xab])))

	/**
	**/
	/** ALL START E2. (⌽ 8c bd)(⍟ 8d 9F)(⎡8e A1)(⎤ 8e A4)(⎣ 8e A3)(❫ 9D AB) **/

%%
%{	/** Code  executed at the beginning of yylex **/
	yylval = lval;
	yy_flex_debug=0;
%}

	/** everything is unrestricted in literal ⎣ context, except for close literal. E2 8E A6 = close lit **/
<literal>{
	{NOT_LITERAL_OUT}*{LITERAL_OUT} {
		yylval->build<std::string>(std::string(yytext, yyleng -3));
		yy_pop_state(); /**  Pop Literal **/
		return( token::TEXT );
	}
	
	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close literal before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(),*loc);
		yy_pop_state();
	}

}

<parm>{

	{DELIMITER} {
		/** yylval->build<std::string>(std::string(yytext, yyleng -1)); **/
		return( token::PARM );
	}

	{BRACKET_OUT} {
		if(yy_top_state() == macro) {
			yylval->build<std::string>(std::string(yytext, yyleng -1));
			yy_pop_state(); /**  Pop Parm to macro **/
			yy_pop_state(); /**  Pop Macro **/
			return( token::MACRO_OUT );
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /** yymore(); **/
		}
	}

	{FAT_ONE_OUT} {
		if(yy_top_state() == fatmac) {
			yylval->build<std::string>(std::string(yytext, yyleng -3));
			yy_pop_state(); /**  Pop Parm to macro **/
			yy_pop_state(); /**  Pop Macro **/
			return( token::MACRO_OUT );
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /** yymore(); **/
		}
	}

	{BRACE_OUT} {
	    yylval->build<std::string>(yytext);
        return( token::TEXT );
		/** yymore(); **/
	}

	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close macro before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(),*loc);
		yy_pop_state();
	}

}

	/** braces are to be honoured in brace and parm context only **/
<parm,brace>{BRACE_IN} {
	yy_push_state(brace);
}

  /** brackets are to be honoured in brackets and parm context only **/
<parm,bracket>{BRACKET_IN} {
    yylval->build<std::string>(yytext);
	yy_push_state(bracket);
    return( token::TEXT );
 	/** yymore(); **/
}

  /** comma is unrestricted inside brace or bracket. Maybe we can fix these text tokens later.. **/
<brace,bracket>{DELIMITER} {
    yylval->build<std::string>(yytext);
    return( token::TEXT );
}

	/** brackets are unrestricted in brace context, close brace pops **/
<brace>{

	{BRACE_OUT} {
		yylval->build<std::string>(std::string(yytext, yyleng -3));
		yy_pop_state();
		return( token::TEXT );
	}

	({BRACKET_IN}|{BRACKET_OUT}|{FAT_ONE_IN}|{FAT_ONE_OUT})+ {
        yylval->build<std::string>(yytext);
        return( token::TEXT );
        /** yymore(); **/
	};
	
	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close brace before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(),*loc);
		yy_pop_state();
	}

}

	/** braces are unrestricted in bracket context, close bracket pops **/
<bracket>{

	{BRACKET_OUT} {
		yylval->build<std::string>(yytext);
		yy_pop_state();
		return( token::TEXT );
	}

	({BRACE_IN}|{BRACE_OUT}|{FAT_ONE_IN}|{FAT_ONE_OUT})+ {
        yylval->build<std::string>(yytext);
        return( token::TEXT );
        /** yymore(); **/
	}
	
	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close bracket before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(),*loc);
		yy_pop_state();
	}

}

	/** honour (fat)macros and injections anywhere but in a macro name,literal **/
<INITIAL,parm,brace,bracket>{

	{LITERAL_IN} {
		yy_push_state(literal);
	}

		({WHITESPACE})+ {
			std::string value(YYText());
			if(value.find_first_of ("\x0d\x0a") != std::string::npos) {
				loc->lines();
				loc->end.column = 1;
			}
			if(!stripped) {
				yylval->build<std::string>(yytext);
				return( token::WSS );
			}
		}

	{MACRO_SIGN}{MACRO_NAME}{BRACKET_IN} {
		yylval->build< std::string >( std::string(yytext + 3, yyleng -4) );
		yy_push_state(macro);
		yy_push_state(parm);
		return( token::MACRO_IN );
	}

	{MACRO_SIGN}{MACRO_NAME}{FAT_ONE_IN} {
		yylval->build< std::string >( std::string(yytext + 3, yyleng -6) );
		yy_push_state(fatmac);
		yy_push_state(parm);
		return( token::MACRO_IN );
	}

	{INJECT_SIGN}{I_OFFSET}({I_NUMBER}|{I_ITS}|({BRACKET_IN}{I_OFFSET}({I_STACK}|{I_ITER}|{I_MORE}){BRACKET_OUT})) {
		if(defining) {
			yylval->build< std::string >(std::string(yytext+3, yyleng -3));
			return(token::INJECTION);
		} else {
			yylval->build< std::string >( yytext );
			return( token::TEXT );
		}
	}

	/** NOT ",\t\n()⌽⍟⎡⎤⎣❫" **/
	({NOT_SPECIAL_1C}|{NOT_SPECIAL_3C})+ {
		yylval->build<std::string>(yytext);
		return( token::TEXT );
	}

	{MACRO_SIGN}|{INJECT_SIGN} {
		yylval->build<std::string>(yytext);
		return( token::TEXT );
    }


}

<INITIAL>{

	({DELIMITER}|{BRACKET_IN}|{BRACKET_OUT}|{BRACE_OUT}|{FAT_ONE_OUT})+ {
		yylval->build< std::string >(yytext);
		return(token::TEXT);
	}

	{BRACE_IN} {
		yy_push_state(brace);
		/**
		if(!defining) {
			yy_push_state(brace);
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /-- yymore(); --/
		}
		**/
	}

}

.	{
	std::ostringstream eStream;
	eStream << "Unexpected character " << yytext;
	errs << Support::Message(Support::syntax,eStream.str(),*loc);
	yy_pop_state();
}

%%

