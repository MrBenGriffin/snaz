%{
/* C++ string header, for string ops below */
#include <cstring>
#include <string>
#include <iostream>
#include <algorithm>

/* Implementation of yyFlexScanner */
#include "parser.tab.hpp"
#include "mt/Scanner.h"
#include "support/Message.h"
#include "support/Fandr.h"

namespace mt {
	class Classic : public Scanner, public cFlexLexer {
	public:
		Classic(Support::Messages& m,std::istream *in) : Scanner(m),cFlexLexer(in) {}
		virtual ~Classic() = default;
		using cFlexLexer::yylex;
		virtual int yylex(mt::Parser::semantic_type *const,mt::Parser::location_type *);
		virtual void LexerError(const char* msg) {
				std::string err(msg); errs << Support::Message(Support::fatal,err);
    }
	private:
		mt::Parser::semantic_type *yylval = nullptr;
	};
}

#undef  YY_DECL
#define YY_DECL int mt::Classic::yylex(mt::Parser::semantic_type * const lval, mt::Parser::location_type *loc)

/* typedef to make the returns for the tokens shorter */
using token = mt::Parser::token;

/* define yyterminate as this instead of NULL */
#define yyterminate() return( token::END )

/* update location on matching */
#define YY_USER_ACTION loc->step();  loc->columns(Support::length(yytext, yyleng));

%}
%option debug
%option yyclass="mt::Classic"
%option prefix="c"
%option noyywrap noinput nounput nodefault
%option noyymore
%option never-interactive
%option c++
%option stack
%option warn
%x macro fatmac parm brace bracket literal injection

  /** ,\t\n()@%{}❪❫ **/
DELIMITER	,
BRACKET_IN	\(
BRACKET_OUT	\)
FAT_ONE_IN	❪
FAT_ONE_OUT	❫
LITERAL_IN	\{\|
BRACE_IN	\{
BRACE_OUT	\}
INJECT_SIGN	%
I_OFFSET	(^*)
I_NUMBER	([0-9]+)
I_ITS		[ijkn]
I_STACK		p(s|[0-9]+)?
I_ITER		([ijkn]([.+-][0-9]+)?)
I_MORE		([0-9]+("+"?))
MACRO_SIGN	@
MACRO_NAME	[a-zA-Z_0-9]+
WHITESPACE	[\t\x0d\x0a]+
LITERAL_OUT			\|\}
NOT_LITERAL_OUT		([^|]|\|[^}])

NOT_SPECIAL_1C		([^\t\x0d\x0a,\(\)\{\}@%\xe2])
NOT_SPECIAL_3C		(\xe2(([^\x9d][^\0])|(\x9d[^\xab])))

	/**
	**/
	/** ALL START E2. (⌽ 8c bd)(⍟ 8d 9F)(⎡8e A1)(⎤ 8e A4)(⎣ 8e A3)(❫ 9D AB) **/

%%
%{	/** Code  executed at the beginning of yylex **/
	yylval = lval; /** read in from yylex **/
	yy_flex_debug=0;
%}

	/** everything is unrestricted in literal ⎣ context, except for close literal. E2 8E A6 = close lit **/
<literal>{

	{NOT_LITERAL_OUT}*{LITERAL_OUT} {
		yylval->build<std::string>(std::string(yytext, yyleng -2));
		yy_pop_state(); /**  Pop Literal **/
		return( token::TEXT );
	}

	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close literal before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(),*loc);
		yy_pop_state();
	}

}

<parm>{

	{DELIMITER} {
		/** yylval->build<std::string>(std::string(yytext, yyleng -1)); **/
		return( token::PARM );
	}

	{BRACKET_OUT} {
		if(yy_top_state() == macro) {
			yylval->build<std::string>(std::string(yytext, yyleng -1));
			yy_pop_state(); /**  Pop Parm to macro **/
			yy_pop_state(); /**  Pop Macro **/
			return( token::MACRO_OUT );
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /** yymore(); **/
		}
	}

	{FAT_ONE_OUT} {
		if(yy_top_state() == fatmac) {
			yylval->build<std::string>(std::string(yytext, yyleng -3));
			yy_pop_state(); /**  Pop Parm to macro **/
			yy_pop_state(); /**  Pop Macro **/
			return( token::MACRO_OUT );
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /** yymore(); **/
		}
	}

	{BRACE_OUT} {
	    yylval->build<std::string>(yytext);
        return( token::TEXT );
		/** yymore(); **/
	}

	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close macro before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(), *loc);
		yy_pop_state();
	}

}

	/** braces are to be honoured in brace and parm context only **/
<parm,brace>{BRACE_IN} {
	yy_push_state(brace);
}

  /** brackets are to be honoured in brackets and parm context only **/
<parm,bracket>{BRACKET_IN} {
    yylval->build<std::string>(yytext);
	yy_push_state(bracket);
    return( token::TEXT );
 	/** yymore(); **/
}

  /** comma is unrestricted inside brace or bracket. Maybe we can fix these text tokens later.. **/
<brace,bracket>{DELIMITER} {
    yylval->build<std::string>(yytext);
    return( token::TEXT );
}

	/** brackets are unrestricted in brace context, close brace pops **/
<brace>{

	{BRACE_OUT} {
		yylval->build<std::string>(std::string(yytext, yyleng -1));
		yy_pop_state();
		return( token::TEXT );
	}

	({BRACKET_IN}|{BRACKET_OUT}|{FAT_ONE_IN}|{FAT_ONE_OUT})+ {
        yylval->build<std::string>(yytext);
        return( token::TEXT );
        /** yymore(); **/
	};
	
	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close brace before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(), *loc);
		yy_pop_state();
	}


}

	/** braces are unrestricted in bracket context, close bracket pops **/
<bracket>{

	{BRACKET_OUT} {
		yylval->build<std::string>(yytext);
		yy_pop_state();
		return( token::TEXT );
	}

	({BRACE_IN}|{BRACE_OUT}|{FAT_ONE_IN}|{FAT_ONE_OUT})+ {
        yylval->build<std::string>(yytext);
        return( token::TEXT );
        /** yymore(); **/
	}

	<<EOF>> {
		std::ostringstream eStream;
		eStream << "expected close bracket before end of text" << yytext;
		errs << Support::Message(Support::syntax,eStream.str(), *loc);
		yy_pop_state();
	}


}

	/** honour (fat)macros and injections anywhere but in a macro name,literal **/
<INITIAL,parm,brace,bracket>{

	{LITERAL_IN} {
		yy_push_state(literal);
	}

	({WHITESPACE}) {
		std::string value(YYText());
		if(value.find_first_of ("\x0d\x0a") != std::string::npos) {
			size_t d = std::count(value.begin(), value.end(), '\x0d');
			size_t a = std::count(value.begin(), value.end(), '\x0a');
			size_t t = value.find_last_not_of("\x09");
			t = t == std::string::npos ? value.size() : value.size() - (t + 1);
			loc->lines(d == 0 ? a:d );
			loc->end.column = 1 + t;
		}
		if(!stripped) {
			yylval->build<std::string>(yytext);
			return( token::WSS );
		}
	}

	{MACRO_SIGN}{MACRO_NAME}{BRACKET_IN} {
		yylval->build< std::string >( std::string(yytext + 1, yyleng -2) );
		yy_push_state(macro);
		yy_push_state(parm);
		return( token::MACRO_IN );
	}

	{MACRO_SIGN}{MACRO_NAME}{FAT_ONE_IN} {
		yylval->build< std::string >( std::string(yytext + 1, yyleng -4) );
		yy_push_state(fatmac);
		yy_push_state(parm);
		return( token::MACRO_IN );
	}

	{MACRO_SIGN}{MACRO_NAME}{NOT_SPECIAL_1C} {
		yylval->build<std::string>(yytext);
		return( token::TEXT );
	}

	{INJECT_SIGN}{I_OFFSET}({I_NUMBER}|{I_ITS}|({BRACKET_IN}{I_OFFSET}({I_STACK}|{I_ITER}|{I_MORE}){BRACKET_OUT})) {
		if(defining) {
			yylval->build< std::string >(std::string(yytext+1, yyleng -1));
			return(token::INJECTION);
		} else {
			yylval->build< std::string >( yytext );
			return( token::TEXT );
		}
	}

	/** NOT ",\t\n()⌽⍟⎡⎤⎣❫" **/
	({NOT_SPECIAL_1C}|{NOT_SPECIAL_3C})+ {
		yylval->build<std::string>(yytext);
		return( token::TEXT );
	}

	{MACRO_SIGN}|{INJECT_SIGN} {
		yylval->build<std::string>(yytext);
		return( token::TEXT );
    }
		
}


<INITIAL>{

	({DELIMITER}|{BRACKET_IN}|{BRACKET_OUT}|{BRACE_OUT}|{FAT_ONE_OUT})+ {
		yylval->build< std::string >(yytext);
		return(token::TEXT);
	}

	{BRACE_IN} {
		yy_push_state(brace);
		/**
		if(!defining) {
			yy_push_state(brace);
		} else {
            yylval->build<std::string>(yytext);
            return( token::TEXT );
            /-- yymore(); --/
		}
		**/
	}


}


.	{
		std::ostringstream eStream;
		eStream << "unexpected character " << yytext;
		errs << Support::Message(Support::syntax,eStream.str(), *loc);
		yy_pop_state();
	}

%%

