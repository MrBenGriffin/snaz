%skeleton "lalr1.cc"
%require  "3.3"
%defines
%define api.namespace {mt}
%define api.parser.class {Parser}
%define parse.trace

%code requires{
  namespace Support {
      class Messages;
  }
  namespace mt {
      class Driver;
      class Scanner;
   }
}

%parse-param { Support::Messages& errs  }
%parse-param { Scanner* scanner }
%parse-param { Driver& driver  }

%code{
   #include <iostream>
   #include <cstdlib>
   #include <fstream>
   #include "location.hh"
   #include "mt/Driver.h"
   #include "mt/Scanner.h"
   #include "support/Message.h"

#undef yylex
#define yylex scanner->yylex
}

%define api.value.type variant
%define parse.assert

%token               END    0     "end of file"
%token PARM
%token <std::string> TEXT
%token <std::string> WSS
%token <std::string> MACRO_IN
%token <std::string> MACRO_OUT
%token <std::string> INJECTION

%locations

%%

list_option : END | list END;

list
  : item
  | list item
  ;

item
  : TEXT			{ driver.store($1); }
  | WSS		        { driver.storeWss($1); }
  | INJECTION		{ driver.inject($1); }
  | macro			{ driver.store_macro(); }
  ;

macro
  : MACRO_IN		{ driver.new_macro($1); }
    parms
    MACRO_OUT		{ driver.store($4); driver.add_parm(); }
  ;

parms
  : %empty
  | parm
  | parms parm
  ;

parm
  : pitem
  | parm pitem

pitem
  : PARM			{ driver.add_parm(); }
  | WSS		        { driver.storeWss($1); }
  | TEXT			{ driver.store($1); }
  | INJECTION		{ driver.inject($1); }
  | macro			{ driver.store_macro(); }
  ;

%%
void mt::Parser::error( const location_type &l, const std::string &err_message ) {
  /**	mt::pos p({{l.begin.line,l.begin.column},{l.end.line,l.end.column}}); **/
	mt::pos p({l.begin.column,l.end.column});
	driver.setPos(p);
	errs << Message(syntax,err_message);
}

