%skeleton "lalr1.cc"
%require  "3.2"
%defines
%define api.namespace {mt}
%define parser_class_name {Parser}
%define parse.trace

%code requires{
   namespace mt {
      class Driver;
      class Advanced;
   }
}

%parse-param { Advanced  &scanner }
%parse-param { Driver    &driver  }
  /**
    %parse-param { bool    stripped  }
    %parse-param { bool    defining  }
 **/
%code{
   #include <iostream>
   #include <cstdlib>
   #include <fstream>
   #include "../Driver.h"

#undef yylex
#define yylex scanner.yylex
}

%define api.value.type variant
%define parse.assert

%token               END    0     "end of file"
%token PARM
%token <std::string> TEXT
%token <std::string> WSS
%token <std::string> MACRO_IN
%token <std::string> MACRO_OUT
%token <std::string> INJECTION

%locations

%%

list_option : END | list END;

list
  : item
  | list item
  ;

item
  : TEXT			{ driver.store($1); }
  | WSS		        { driver.storeWss($1); }
  | INJECTION		{ driver.inject($1); }
  | macro			{ driver.store_macro(); }
  ;

macro
  : MACRO_IN		{ driver.new_macro($1); }
    parms
    MACRO_OUT		{ driver.store($4); driver.add_parm(); }
  ;

parms
  : %empty
  | parm
  | parms parm
  ;

parm
  : pitem
  | parm pitem

pitem
  : PARM			{ driver.add_parm(); }
  | WSS		        { driver.storeWss($1); }
  | TEXT			{ driver.store($1); }
  | INJECTION		{ driver.inject($1); }
  | macro			{ driver.store_macro(); }
  ;

%%
void mt::Parser::error( const location_type &l, const std::string &err_message ) {
   std::cerr << "Error: ";
   std::cerr << err_message << " at " << l << "\n";
}
